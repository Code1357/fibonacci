*** アルゴリズム ***

* フィボナッチ数列を40番まで出力する
* 数列：1,2,3,4,5,・・・・と、いくつかの数を並べたもの
* 数式：F0 = 0  , F1 = 1 , Fn = Fn-1 + Fn-2(n ≧ 2) となる
* 0 番目は 0、1 番目は 1、その後はその前とその前の前の値を足したものとなる
* 例) 0=0, 1=1, 0+1=1, 1+1 =2, 1+2=3 ・・・・

* time node app.js : 実行するのにかかった時間を確認する 
* 実行が終わらない場合、Ctrl + c で解除する

* この関数で足し算がされる回数を、再帰関数を読み解きながら書き出していくと、

n が２の時の fib(2) は、fib(1) + fib(0)、つまり、0 + 0 + 1 で 1 回
n が３の時の fib(3) は、fib(2) + fib(1)、これは、1 + 0 + 1 で 2 回
n が４の時の fib(4) は、fib(3) + fib(2)、これは、2 + 1 + 1 で 4 回
n が５の時の fib(5) は、fib(4) + fib(3)、これは、4 + 2 + 1 で 7 回
n が６の時の fib(6) は、fib(5) + fib(4)、これは、7 + 4 + 1 で 12 回
n が７の時の fib(7) は、fib(6) + fib(5)、これは、12 + 7 + 1 で 20 回
n が８の時の fib(8) は、fib(7) + fib(6)、これは、20 + 12 + 1 で 33 回
n が 50 の時の fib(50) は、fib(49) + fib(48)、これは、12,586,269,024 + 7,778,742,048 + 1 で 20,365,011,073 回
n が 100 の時の fib(100) は、fib(99) + fib(98)、これは、354,224,848,179,261,915,074 + 218,922,995,834,555,169,025 + 1 で 573,147,844,013,817,084,100 回
のようになる。

厳密には倍々ではではないが、

このように、回を重ねると後に倍々に計算回数が増えるような処理の増え方を指数（しすう）オーダーという。
O 記法（オーきほう）というオーダーを表す記法で

O(2n)　と記述する。

*** プロファイルツールを使う ***

* Node.jsに組み込まれているプロファイルツールの利用
* $ node --prof app.js
* プロファイルがディレクトリ内に生成される
* プロファイルの結果の確認
* $ node --prof-process 生成されたプロファイル名
* Summary が、プログラムの処理全体の概要が示されている
* Bottom up (heavy) profile が、時間のかかった処理が並んでいる
* ticks　の列は、各処理にかかったイベントループ数を示している

* Map を使う
* 参考URL：https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Map
* Mapメソッドは、挿入順で反復処理を行える
* $ node
* $ var etoMap = new Map(); // new はインスタンス
* データの追加/set メソッドを使う
* $ etoMap.set('子', 'mouse');
* $ etoMap.set('丑', 'cow');
* データの参照/ get メソッドを使う
* $ etoMap.set('丑');
* $ 'cow'

* Map は、数をkeyにする事もできる
* カレンダーの月とれに対応する英単語を保存してみる
* $ var calendarMap = new Map();
* $ calendarMap.set(1, 'Janyuary');
* $ calendarMap.set(2, 'February');
* $ calendarMap.get(1);
* $ 'Janyuary'

* メモ化を使ったアルゴリズムの改善がされた fib 関数のオーダーは、O 記法で表すと

O(n) となる

このような n に対して n 倍処理時間がかかるオーダーを線形（せんけい）オーダーという

この線形オーダーであれば、基本的には n に対して n 倍の時間をかければ問題を解くことができるという状態となる

プログラミングをする上で、アルゴリズムを考えることは重要

オーダーを低く抑えることができれば、必要な PC のスペックが下がるほか、レンタルサーバーやクラウド環境で実行するときにはコストが削減できる
